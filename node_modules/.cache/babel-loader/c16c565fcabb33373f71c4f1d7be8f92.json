{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\n/** @type {Construct} */\n\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n};\n/** @type {Construct} */\n\nconst nonLazyLine = {\n  tokenize: tokenizeNonLazyLine,\n  partial: true\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  const initialSize = tail && tail[1].type === 'linePrefix' ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let sizeOpen = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('mathFlow');\n    effects.enter('mathFlowFence');\n    effects.enter('mathFlowFenceSequence');\n    return sequenceOpen(code);\n  }\n  /** @type {State} */\n\n\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n\n    effects.exit('mathFlowFenceSequence');\n    return sizeOpen < 2 ? nok(code) : factorySpace(effects, metaOpen, 'whitespace')(code);\n  }\n  /** @type {State} */\n\n\n  function metaOpen(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code);\n    }\n\n    effects.enter('mathFlowFenceMeta');\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return meta(code);\n  }\n  /** @type {State} */\n\n\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString');\n      effects.exit('mathFlowFenceMeta');\n      return openAfter(code);\n    }\n\n    if (code === 36) return nok(code);\n    effects.consume(code);\n    return meta;\n  }\n  /** @type {State} */\n\n\n  function openAfter(code) {\n    effects.exit('mathFlowFence');\n    return self.interrupt ? ok(code) : contentStart(code);\n  }\n  /** @type {State} */\n\n\n  function contentStart(code) {\n    if (code === null) {\n      return after(code);\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(nonLazyLine, effects.attempt({\n        tokenize: tokenizeClosingFence,\n        partial: true\n      }, after, initialSize ? factorySpace(effects, contentStart, 'linePrefix', initialSize + 1) : contentStart), after)(code);\n    }\n\n    effects.enter('mathFlowValue');\n    return contentContinue(code);\n  }\n  /** @type {State} */\n\n\n  function contentContinue(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue');\n      return contentStart(code);\n    }\n\n    effects.consume(code);\n    return contentContinue;\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    effects.exit('mathFlow');\n    return ok(code);\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0;\n    return factorySpace(effects, closingPrefixAfter, 'linePrefix', 4);\n    /** @type {State} */\n\n    function closingPrefixAfter(code) {\n      effects.enter('mathFlowFence');\n      effects.enter('mathFlowFenceSequence');\n      return closingSequence(code);\n    }\n    /** @type {State} */\n\n\n    function closingSequence(code) {\n      if (code === 36) {\n        effects.consume(code);\n        size++;\n        return closingSequence;\n      }\n\n      if (size < sizeOpen) return nok(code);\n      effects.exit('mathFlowFenceSequence');\n      return factorySpace(effects, closingSequenceEnd, 'whitespace')(code);\n    }\n    /** @type {State} */\n\n\n    function closingSequenceEnd(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence');\n        return ok(code);\n      }\n\n      return nok(code);\n    }\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeNonLazyLine(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding');\n    return lineStart;\n  }\n  /** @type {State} */\n\n\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}","map":{"version":3,"sources":["/Users/barnabynapier/Documents/programming/personal-site/node_modules/micromark-extension-math/lib/math-flow.js"],"names":["factorySpace","markdownLineEnding","mathFlow","tokenize","tokenizeMathFenced","concrete","nonLazyLine","tokenizeNonLazyLine","partial","effects","ok","nok","self","tail","events","length","initialSize","type","sliceSerialize","sizeOpen","start","code","enter","sequenceOpen","consume","exit","metaOpen","openAfter","contentType","meta","interrupt","contentStart","after","attempt","tokenizeClosingFence","contentContinue","size","closingPrefixAfter","closingSequence","closingSequenceEnd","lineStart","parser","lazy","now","line"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n}\n/** @type {Construct} */\n\nconst nonLazyLine = {\n  tokenize: tokenizeNonLazyLine,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  const initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('mathFlow')\n    effects.enter('mathFlowFence')\n    effects.enter('mathFlowFenceSequence')\n    return sequenceOpen(code)\n  }\n  /** @type {State} */\n\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    effects.exit('mathFlowFenceSequence')\n    return sizeOpen < 2\n      ? nok(code)\n      : factorySpace(effects, metaOpen, 'whitespace')(code)\n  }\n  /** @type {State} */\n\n  function metaOpen(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('mathFlowFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n  /** @type {State} */\n\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('mathFlowFenceMeta')\n      return openAfter(code)\n    }\n\n    if (code === 36) return nok(code)\n    effects.consume(code)\n    return meta\n  }\n  /** @type {State} */\n\n  function openAfter(code) {\n    effects.exit('mathFlowFence')\n    return self.interrupt ? ok(code) : contentStart(code)\n  }\n  /** @type {State} */\n\n  function contentStart(code) {\n    if (code === null) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyLine,\n        effects.attempt(\n          {\n            tokenize: tokenizeClosingFence,\n            partial: true\n          },\n          after,\n          initialSize\n            ? factorySpace(effects, contentStart, 'linePrefix', initialSize + 1)\n            : contentStart\n        ),\n        after\n      )(code)\n    }\n\n    effects.enter('mathFlowValue')\n    return contentContinue(code)\n  }\n  /** @type {State} */\n\n  function contentContinue(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue')\n      return contentStart(code)\n    }\n\n    effects.consume(code)\n    return contentContinue\n  }\n  /** @type {State} */\n\n  function after(code) {\n    effects.exit('mathFlow')\n    return ok(code)\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n    return factorySpace(effects, closingPrefixAfter, 'linePrefix', 4)\n    /** @type {State} */\n\n    function closingPrefixAfter(code) {\n      effects.enter('mathFlowFence')\n      effects.enter('mathFlowFenceSequence')\n      return closingSequence(code)\n    }\n    /** @type {State} */\n\n    function closingSequence(code) {\n      if (code === 36) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      }\n\n      if (size < sizeOpen) return nok(code)\n      effects.exit('mathFlowFenceSequence')\n      return factorySpace(effects, closingSequenceEnd, 'whitespace')(code)\n    }\n    /** @type {State} */\n\n    function closingSequenceEnd(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence')\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNonLazyLine(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return lineStart\n  }\n  /** @type {State} */\n\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}