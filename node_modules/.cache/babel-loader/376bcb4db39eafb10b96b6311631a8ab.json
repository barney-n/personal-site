{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('katex').KatexOptions} KatexOptions\n */\n\n/**\n * @typedef {Omit<KatexOptions, 'displayMode'>} Options\n */\nimport katex from 'katex';\n/**\n * @param {Options} [options]\n * @returns {HtmlExtension}\n */\n\nexport function mathHtml(options) {\n  return {\n    enter: {\n      mathFlow() {\n        this.lineEndingIfNeeded();\n        this.tag('<div class=\"math math-display\">');\n      },\n\n      mathFlowFenceMeta() {\n        this.buffer();\n      },\n\n      mathText() {\n        // Double?\n        this.tag('<span class=\"math math-inline\">');\n        this.buffer();\n      }\n\n    },\n    exit: {\n      mathFlow() {\n        const value = this.resume();\n        this.tag(math(value.replace(/(?:\\r?\\n|\\r)$/, ''), true));\n        this.tag('</div>');\n        this.setData('mathFlowOpen');\n        this.setData('slurpOneLineEnding');\n      },\n\n      mathFlowFence() {\n        // After the first fence.\n        if (!this.getData('mathFlowOpen')) {\n          this.setData('mathFlowOpen', true);\n          this.setData('slurpOneLineEnding', true);\n          this.buffer();\n        }\n      },\n\n      mathFlowFenceMeta() {\n        this.resume();\n      },\n\n      mathFlowValue(token) {\n        this.raw(this.sliceSerialize(token));\n      },\n\n      mathText() {\n        const value = this.resume();\n        this.tag(math(value, false));\n        this.tag('</span>');\n      },\n\n      mathTextData(token) {\n        this.raw(this.sliceSerialize(token));\n      }\n\n    }\n  };\n  /**\n   * @param {string} value\n   * @param {boolean} displayMode\n   * @returns {string}\n   */\n\n  function math(value, displayMode) {\n    return katex.renderToString(value, Object.assign({}, options, {\n      displayMode\n    }));\n  }\n}","map":{"version":3,"sources":["/Users/barnabynapier/Documents/programming/personal-site/node_modules/micromark-extension-math/lib/html.js"],"names":["katex","mathHtml","options","enter","mathFlow","lineEndingIfNeeded","tag","mathFlowFenceMeta","buffer","mathText","exit","value","resume","math","replace","setData","mathFlowFence","getData","mathFlowValue","token","raw","sliceSerialize","mathTextData","displayMode","renderToString","Object","assign"],"mappings":"AAAA;;;;;AAKA;;;AAGA,OAAOA,KAAP,MAAkB,OAAlB;AACA;;;;;AAKA,OAAO,SAASC,QAAT,CAAkBC,OAAlB,EAA2B;AAChC,SAAO;AACLC,IAAAA,KAAK,EAAE;AACLC,MAAAA,QAAQ,GAAG;AACT,aAAKC,kBAAL;AACA,aAAKC,GAAL,CAAS,iCAAT;AACD,OAJI;;AAMLC,MAAAA,iBAAiB,GAAG;AAClB,aAAKC,MAAL;AACD,OARI;;AAULC,MAAAA,QAAQ,GAAG;AACT;AACA,aAAKH,GAAL,CAAS,iCAAT;AACA,aAAKE,MAAL;AACD;;AAdI,KADF;AAiBLE,IAAAA,IAAI,EAAE;AACJN,MAAAA,QAAQ,GAAG;AACT,cAAMO,KAAK,GAAG,KAAKC,MAAL,EAAd;AACA,aAAKN,GAAL,CAASO,IAAI,CAACF,KAAK,CAACG,OAAN,CAAc,eAAd,EAA+B,EAA/B,CAAD,EAAqC,IAArC,CAAb;AACA,aAAKR,GAAL,CAAS,QAAT;AACA,aAAKS,OAAL,CAAa,cAAb;AACA,aAAKA,OAAL,CAAa,oBAAb;AACD,OAPG;;AASJC,MAAAA,aAAa,GAAG;AACd;AACA,YAAI,CAAC,KAAKC,OAAL,CAAa,cAAb,CAAL,EAAmC;AACjC,eAAKF,OAAL,CAAa,cAAb,EAA6B,IAA7B;AACA,eAAKA,OAAL,CAAa,oBAAb,EAAmC,IAAnC;AACA,eAAKP,MAAL;AACD;AACF,OAhBG;;AAkBJD,MAAAA,iBAAiB,GAAG;AAClB,aAAKK,MAAL;AACD,OApBG;;AAsBJM,MAAAA,aAAa,CAACC,KAAD,EAAQ;AACnB,aAAKC,GAAL,CAAS,KAAKC,cAAL,CAAoBF,KAApB,CAAT;AACD,OAxBG;;AA0BJV,MAAAA,QAAQ,GAAG;AACT,cAAME,KAAK,GAAG,KAAKC,MAAL,EAAd;AACA,aAAKN,GAAL,CAASO,IAAI,CAACF,KAAD,EAAQ,KAAR,CAAb;AACA,aAAKL,GAAL,CAAS,SAAT;AACD,OA9BG;;AAgCJgB,MAAAA,YAAY,CAACH,KAAD,EAAQ;AAClB,aAAKC,GAAL,CAAS,KAAKC,cAAL,CAAoBF,KAApB,CAAT;AACD;;AAlCG;AAjBD,GAAP;AAsDA;;;;;;AAMA,WAASN,IAAT,CAAcF,KAAd,EAAqBY,WAArB,EAAkC;AAChC,WAAOvB,KAAK,CAACwB,cAAN,CACLb,KADK,EAELc,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBxB,OAAlB,EAA2B;AACzBqB,MAAAA;AADyB,KAA3B,CAFK,CAAP;AAMD;AACF","sourcesContent":["/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('katex').KatexOptions} KatexOptions\n */\n\n/**\n * @typedef {Omit<KatexOptions, 'displayMode'>} Options\n */\nimport katex from 'katex'\n/**\n * @param {Options} [options]\n * @returns {HtmlExtension}\n */\n\nexport function mathHtml(options) {\n  return {\n    enter: {\n      mathFlow() {\n        this.lineEndingIfNeeded()\n        this.tag('<div class=\"math math-display\">')\n      },\n\n      mathFlowFenceMeta() {\n        this.buffer()\n      },\n\n      mathText() {\n        // Double?\n        this.tag('<span class=\"math math-inline\">')\n        this.buffer()\n      }\n    },\n    exit: {\n      mathFlow() {\n        const value = this.resume()\n        this.tag(math(value.replace(/(?:\\r?\\n|\\r)$/, ''), true))\n        this.tag('</div>')\n        this.setData('mathFlowOpen')\n        this.setData('slurpOneLineEnding')\n      },\n\n      mathFlowFence() {\n        // After the first fence.\n        if (!this.getData('mathFlowOpen')) {\n          this.setData('mathFlowOpen', true)\n          this.setData('slurpOneLineEnding', true)\n          this.buffer()\n        }\n      },\n\n      mathFlowFenceMeta() {\n        this.resume()\n      },\n\n      mathFlowValue(token) {\n        this.raw(this.sliceSerialize(token))\n      },\n\n      mathText() {\n        const value = this.resume()\n        this.tag(math(value, false))\n        this.tag('</span>')\n      },\n\n      mathTextData(token) {\n        this.raw(this.sliceSerialize(token))\n      }\n    }\n  }\n  /**\n   * @param {string} value\n   * @param {boolean} displayMode\n   * @returns {string}\n   */\n\n  function math(value, displayMode) {\n    return katex.renderToString(\n      value,\n      Object.assign({}, options, {\n        displayMode\n      })\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"module"}