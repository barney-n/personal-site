{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n *\n * @typedef Options\n * @property {boolean} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (`boolean`, default:\n *   `true`).\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n */\nimport { markdownLineEnding } from 'micromark-util-character';\n/**\n * @param {Options} [options]\n * @returns {Construct}\n */\n\nexport function mathText(options = {}) {\n  let single = options.singleDollarTextMath;\n\n  if (single === null || single === undefined) {\n    single = true;\n  }\n\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous\n  };\n  /** @type {Tokenizer} */\n\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this;\n    let sizeOpen = 0;\n    /** @type {number} */\n\n    let size;\n    /** @type {Token} */\n\n    let token;\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('mathText');\n      effects.enter('mathTextSequence');\n      return openingSequence(code);\n    }\n    /** @type {State} */\n\n\n    function openingSequence(code) {\n      if (code === 36) {\n        effects.consume(code);\n        sizeOpen++;\n        return openingSequence;\n      }\n\n      if (sizeOpen < 2 && !single) return nok(code);\n      effects.exit('mathTextSequence');\n      return gap(code);\n    }\n    /** @type {State} */\n\n\n    function gap(code) {\n      if (code === null) {\n        return nok(code);\n      } // Closing fence?\n      // Could also be data.\n\n\n      if (code === 36) {\n        token = effects.enter('mathTextSequence');\n        size = 0;\n        return closingSequence(code);\n      } // Tabs don’t work, and virtual spaces don’t make sense.\n\n\n      if (code === 32) {\n        effects.enter('space');\n        effects.consume(code);\n        effects.exit('space');\n        return gap;\n      }\n\n      if (markdownLineEnding(code)) {\n        effects.enter('lineEnding');\n        effects.consume(code);\n        effects.exit('lineEnding');\n        return gap;\n      } // Data.\n\n\n      effects.enter('mathTextData');\n      return data(code);\n    } // In math.\n\n    /** @type {State} */\n\n\n    function data(code) {\n      if (code === null || code === 32 || code === 36 || markdownLineEnding(code)) {\n        effects.exit('mathTextData');\n        return gap(code);\n      }\n\n      effects.consume(code);\n      return data;\n    } // Closing fence.\n\n    /** @type {State} */\n\n\n    function closingSequence(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code);\n        size++;\n        return closingSequence;\n      } // Done!\n\n\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence');\n        effects.exit('mathText');\n        return ok(code);\n      } // More or less accents: mark as data.\n\n\n      token.type = 'mathTextData';\n      return data(code);\n    }\n  }\n}\n/** @type {Resolver} */\n\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4;\n  let headEnterIndex = 3;\n  /** @type {number} */\n\n  let index;\n  /** @type {number|undefined} */\n\n  let enter; // If we start and end with an EOL or a space.\n\n  if ((events[headEnterIndex][1].type === 'lineEnding' || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === 'lineEnding' || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex; // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding';\n        events[headEnterIndex][1].type = 'mathTextPadding';\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === 'lineEnding') {\n      events[enter][1].type = 'mathTextData';\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n\n      enter = undefined;\n    }\n  }\n\n  return events;\n}\n/** @type {Previous} */\n\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== 36 || this.events[this.events.length - 1][1].type === 'characterEscape';\n}","map":{"version":3,"sources":["/Users/barnabynapier/Documents/programming/personal-site/node_modules/micromark-extension-math/lib/math-text.js"],"names":["markdownLineEnding","mathText","options","single","singleDollarTextMath","undefined","tokenize","tokenizeMathText","resolve","resolveMathText","previous","effects","ok","nok","self","sizeOpen","size","token","start","code","enter","openingSequence","consume","exit","gap","closingSequence","data","type","events","tailExitIndex","length","headEnterIndex","index","end","splice"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n *\n * @typedef Options\n * @property {boolean} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (`boolean`, default:\n *   `true`).\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n */\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/**\n * @param {Options} [options]\n * @returns {Construct}\n */\nexport function mathText(options = {}) {\n  let single = options.singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this\n    let sizeOpen = 0\n    /** @type {number} */\n\n    let size\n    /** @type {Token} */\n\n    let token\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('mathText')\n      effects.enter('mathTextSequence')\n      return openingSequence(code)\n    }\n    /** @type {State} */\n\n    function openingSequence(code) {\n      if (code === 36) {\n        effects.consume(code)\n        sizeOpen++\n        return openingSequence\n      }\n\n      if (sizeOpen < 2 && !single) return nok(code)\n      effects.exit('mathTextSequence')\n      return gap(code)\n    }\n    /** @type {State} */\n\n    function gap(code) {\n      if (code === null) {\n        return nok(code)\n      } // Closing fence?\n      // Could also be data.\n\n      if (code === 36) {\n        token = effects.enter('mathTextSequence')\n        size = 0\n        return closingSequence(code)\n      } // Tabs don’t work, and virtual spaces don’t make sense.\n\n      if (code === 32) {\n        effects.enter('space')\n        effects.consume(code)\n        effects.exit('space')\n        return gap\n      }\n\n      if (markdownLineEnding(code)) {\n        effects.enter('lineEnding')\n        effects.consume(code)\n        effects.exit('lineEnding')\n        return gap\n      } // Data.\n\n      effects.enter('mathTextData')\n      return data(code)\n    } // In math.\n\n    /** @type {State} */\n\n    function data(code) {\n      if (\n        code === null ||\n        code === 32 ||\n        code === 36 ||\n        markdownLineEnding(code)\n      ) {\n        effects.exit('mathTextData')\n        return gap(code)\n      }\n\n      effects.consume(code)\n      return data\n    } // Closing fence.\n\n    /** @type {State} */\n\n    function closingSequence(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      } // Done!\n\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence')\n        effects.exit('mathText')\n        return ok(code)\n      } // More or less accents: mark as data.\n\n      token.type = 'mathTextData'\n      return data(code)\n    }\n  }\n}\n/** @type {Resolver} */\n\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n\n  let index\n  /** @type {number|undefined} */\n\n  let enter // If we start and end with an EOL or a space.\n\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding'\n        events[headEnterIndex][1].type = 'mathTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n  index = headEnterIndex - 1\n  tailExitIndex++\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'mathTextData'\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n\n      enter = undefined\n    }\n  }\n\n  return events\n}\n/** @type {Previous} */\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 36 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n"]},"metadata":{},"sourceType":"module"}