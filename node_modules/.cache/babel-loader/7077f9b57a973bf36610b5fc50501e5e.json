{"ast":null,"code":"/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('./complex-types').Math} Math\n * @typedef {import('./complex-types').InlineMath} InlineMath\n *\n * @typedef ToOptions\n * @property {boolean} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (`boolean`, default:\n *   `true`).\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n */\nimport { longestStreak } from 'longest-streak';\nimport { safe } from 'mdast-util-to-markdown/lib/util/safe.js';\nimport { track } from 'mdast-util-to-markdown/lib/util/track.js';\n/**\n * @returns {FromMarkdownExtension}\n */\n\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  };\n  /** @type {FromMarkdownHandle} */\n\n  function enterMathFlow(token) {\n    this.enter({\n      type: 'math',\n      meta: null,\n      value: '',\n      data: {\n        hName: 'div',\n        hProperties: {\n          className: ['math', 'math-display']\n        },\n        hChildren: [{\n          type: 'text',\n          value: ''\n        }]\n      }\n    }, token);\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function enterMathFlowMeta() {\n    this.buffer();\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function exitMathFlowMeta() {\n    const data = this.resume();\n    const node =\n    /** @type {Math} */\n    this.stack[this.stack.length - 1];\n    node.meta = data;\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return;\n    this.buffer();\n    this.setData('mathFlowInside', true);\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    const node =\n    /** @type {Math} */\n    this.exit(token);\n    node.value = data; // @ts-expect-error: we defined it.\n\n    node.data.hChildren[0].value = data;\n    this.setData('mathFlowInside');\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function enterMathText(token) {\n    this.enter({\n      type: 'inlineMath',\n      value: '',\n      data: {\n        hName: 'span',\n        hProperties: {\n          className: ['math', 'math-inline']\n        },\n        hChildren: [{\n          type: 'text',\n          value: ''\n        }]\n      }\n    }, token);\n    this.buffer();\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function exitMathText(token) {\n    const data = this.resume();\n    const node =\n    /** @type {Math} */\n    this.exit(token);\n    node.value = data; // @ts-expect-error: we defined it.\n\n    node.data.hChildren[0].value = data;\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token);\n    this.config.exit.data.call(this, token);\n  }\n}\n/**\n * @param {ToOptions} [options]\n * @returns {ToMarkdownExtension}\n */\n\nexport function mathToMarkdown(options = {}) {\n  let single = options.singleDollarTextMath;\n\n  if (single === null || single === undefined) {\n    single = true;\n  }\n\n  inlineMath.peek = inlineMathPeek;\n  return {\n    unsafe: [{\n      character: '\\r',\n      inConstruct: ['mathFlowMeta']\n    }, {\n      character: '\\r',\n      inConstruct: ['mathFlowMeta']\n    }, single ? {\n      character: '$',\n      inConstruct: ['mathFlowMeta', 'phrasing']\n    } : {\n      character: '$',\n      after: '\\\\$',\n      inConstruct: ['mathFlowMeta', 'phrasing']\n    }, {\n      atBreak: true,\n      character: '$',\n      after: '\\\\$'\n    }],\n    handlers: {\n      math,\n      inlineMath\n    }\n  };\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || '';\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2));\n    const exit = context.enter('mathFlow');\n    const tracker = track(safeOptions);\n    let value = tracker.move(sequence);\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta');\n      value += tracker.move(safe(context, node.meta, { ...tracker.current(),\n        before: value,\n        after: ' ',\n        encode: ['$']\n      }));\n      subexit();\n    }\n\n    value += tracker.move('\\n');\n\n    if (raw) {\n      value += tracker.move(raw + '\\n');\n    }\n\n    value += tracker.move(sequence);\n    exit();\n    return value;\n  }\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n\n\n  function inlineMath(node) {\n    const value = node.value || '';\n    let size = 1;\n    let pad = '';\n    if (!single) size++; // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n\n    while (new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)) {\n      size++;\n    } // If this is not just spaces or eols (tabs don’t count), and either the first\n    // or last character are a space, eol, or dollar sign, then pad with spaces.\n\n\n    if (/[^ \\r\\n]/.test(value) && (/[ \\r\\n$]/.test(value.charAt(0)) || /[ \\r\\n$]/.test(value.charAt(value.length - 1)))) {\n      pad = ' ';\n    }\n\n    const sequence = '$'.repeat(size);\n    return sequence + pad + value + pad + sequence;\n  }\n  /** @type {ToMarkdownHandle} */\n\n\n  function inlineMathPeek() {\n    return '$';\n  }\n}","map":{"version":3,"sources":["/Users/barnabynapier/Documents/programming/personal-site/node_modules/mdast-util-math/index.js"],"names":["longestStreak","safe","track","mathFromMarkdown","enter","mathFlow","enterMathFlow","mathFlowFenceMeta","enterMathFlowMeta","mathText","enterMathText","exit","exitMathFlow","mathFlowFence","exitMathFlowFence","exitMathFlowMeta","mathFlowValue","exitMathData","exitMathText","mathTextData","token","type","meta","value","data","hName","hProperties","className","hChildren","buffer","resume","node","stack","length","getData","setData","replace","config","call","mathToMarkdown","options","single","singleDollarTextMath","undefined","inlineMath","peek","inlineMathPeek","unsafe","character","inConstruct","after","atBreak","handlers","math","_","context","safeOptions","raw","sequence","repeat","Math","max","tracker","move","subexit","current","before","encode","size","pad","RegExp","test","charAt"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('./complex-types').Math} Math\n * @typedef {import('./complex-types').InlineMath} InlineMath\n *\n * @typedef ToOptions\n * @property {boolean} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (`boolean`, default:\n *   `true`).\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n/**\n * @returns {FromMarkdownExtension}\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterMathFlow(token) {\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {\n          hName: 'div',\n          hProperties: {className: ['math', 'math-display']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.stack[this.stack.length - 1])\n    node.meta = data\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return\n    this.buffer()\n    this.setData('mathFlowInside', true)\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n    this.setData('mathFlowInside')\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'span',\n          hProperties: {className: ['math', 'math-inline']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * @param {ToOptions} [options]\n * @returns {ToMarkdownExtension}\n */\nexport function mathToMarkdown(options = {}) {\n  let single = options.singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: ['mathFlowMeta']},\n      {character: '\\r', inConstruct: ['mathFlowMeta']},\n      single\n        ? {character: '$', inConstruct: ['mathFlowMeta', 'phrasing']}\n        : {\n            character: '$',\n            after: '\\\\$',\n            inConstruct: ['mathFlowMeta', 'phrasing']\n          },\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || ''\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = context.enter('mathFlow')\n    const tracker = track(safeOptions)\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta')\n      value += tracker.move(\n        safe(context, node.meta, {\n          ...tracker.current(),\n          before: value,\n          after: ' ',\n          encode: ['$']\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  function inlineMath(node) {\n    const value = node.value || ''\n    let size = 1\n    let pad = ''\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    // If this is not just spaces or eols (tabs don’t count), and either the first\n    // or last character are a space, eol, or dollar sign, then pad with spaces.\n    if (\n      /[^ \\r\\n]/.test(value) &&\n      (/[ \\r\\n$]/.test(value.charAt(0)) ||\n        /[ \\r\\n$]/.test(value.charAt(value.length - 1)))\n    ) {\n      pad = ' '\n    }\n\n    const sequence = '$'.repeat(size)\n    return sequence + pad + value + pad + sequence\n  }\n\n  /** @type {ToMarkdownHandle} */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n"]},"metadata":{},"sourceType":"module"}